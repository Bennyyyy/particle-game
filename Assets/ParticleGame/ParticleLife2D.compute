// ParticleLife2D.compute — 2D, nur Anziehung/Abstoßung (keine Kollisionen)
// Metal-safe (keine .Length), TG = 256

#pragma kernel clear_grid
#pragma kernel clear_next
#pragma kernel add_particles_to_grid
#pragma kernel compute_forces
#pragma kernel integrate

RWStructuredBuffer<float4> _Pos; // xy pos, z=0, w=size
RWStructuredBuffer<float4> _Vel; // xy vel
RWStructuredBuffer<int> _CellHead; // head je Zelle
RWStructuredBuffer<int> _Next; // verkettete Liste

StructuredBuffer<uint> _Type; // pro Partikel: Typindex 0..K-1
StructuredBuffer<float> _AttractMat; // K*K Werte, row-major
int _TypeCount; // = K

int _ParticleCount;
int _CellCount;
int2 _GridRes2D;
float2 _WorldMin;
float2 _WorldMax;
float2 _CellSize2D;

float _InteractRadius, _Damping, _DeltaTime, _MinDistance, _GlobalAttractionMultiplayer;

// --- Helpers ---
int wrap1(int a, int m)
{
    return (a % m + m) % m;
} // immer 0..m-1

int2 wrap2(int2 c, int2 m)
{
    return int2(wrap1(c.x, m.x), wrap1(c.y, m.y));
}

float pairAttr(uint ti, uint tj)
{
    return _AttractMat[ti * _TypeCount + tj] * _GlobalAttractionMultiplayer;
}

uint grid_pos_to_grid_index(int2 pos)
{
    //pos = clamp(pos, int2(0, 0), _GridRes2D - 1);
    pos = wrap2(pos, _GridRes2D);
    return pos.x + _GridRes2D.x * pos.y;
}

int2 safe_floor_to_int2(float2 v)
{
    v = clamp(v, -1e20, 1e20);
    if (isnan(v.x)) v.x = 0;
    if (isnan(v.y)) v.y = 0;
    return int2((int)floor(v.x), (int)floor(v.y));
}

int2 particle_position_to_grid_position(const float2 particle_pos)
{
    const float2 cs = max(_CellSize2D, float2(1e-4, 1e-4));
    const float2 rel = (particle_pos - _WorldMin) / cs;
    return safe_floor_to_int2(rel);
}

float2 torus_delta(float2 a, float2 b, float2 minW, float2 maxW)
{
    float2 size = max(maxW - minW, float2(1e-4, 1e-4));
    float2 d = b - a;
    if (d.x > 0.5 * size.x) d.x -= size.x;
    if (d.x < -0.5 * size.x) d.x += size.x;
    if (d.y > 0.5 * size.y) d.y -= size.y;
    if (d.y < -0.5 * size.y) d.y += size.y;
    return d;
}

// --- Kernels ---
[numthreads(256,1,1)]
void clear_grid(uint3 id : SV_DispatchThreadID)
{
    // guard
    uint idx = id.x;
    if (idx >= (uint)_CellCount) return;

    _CellHead[idx] = -1;
}

[numthreads(256,1,1)]
void clear_next(uint3 id : SV_DispatchThreadID)
{
    // guard
    uint i = id.x;
    if (i >= (uint)_ParticleCount) return;

    _Next[i] = -1;
}

[numthreads(256,1,1)]
void add_particles_to_grid(uint3 id : SV_DispatchThreadID)
{
    // guard
    const uint i = id.x;
    if (i >= (uint)_ParticleCount) return;

    float2 p = _Pos[i].xy;
    p = clamp(p, _WorldMin - 1e3, _WorldMax + 1e3);
    uint h = grid_pos_to_grid_index(particle_position_to_grid_position(p));

    int prev_head;
    InterlockedExchange(_CellHead[h], (int)i, prev_head);
    _Next[i] = prev_head; // -1 wenn leer
}

float calc_force(const float distance, const float attraction)
{
    // min distance force
    if (distance < _MinDistance)
    {
        //const float wMinDistance = dist / _MinDistance - 1;
        //const float fMinDistance = wMinDistance;
        //force = min(f, fMinDistance);

        const float w = 1.0 - distance / _MinDistance;
        return -1 * w;
    }
    else
    {
        return attraction * (1 - (abs(2 * distance - _InteractRadius - _MinDistance) / _InteractRadius - _MinDistance));

        // user force
        //const float w = 1.0 - distance / _InteractRadius;
        //return attraction * w;
    }
}

float2 neighbour_force(const uint particle_index, const float2 particle_pos)
{
    float2 totalForce = 0;
    const int2 grid_pos = particle_position_to_grid_position(particle_pos);

    const int grid_radius = (int)ceil(_InteractRadius / _CellSize2D.x);

    for (int y = -grid_radius; y <= grid_radius; y++)
        for (int x = -grid_radius; x <= grid_radius; x++)
        {
            uint current_grid_index = grid_pos_to_grid_index(grid_pos + int2(x, y));
            int current_particle_index = _CellHead[current_grid_index];

            [loop] while (current_particle_index != -1)
            {
                if ((uint)current_particle_index != particle_index)
                {
                    const float2 distance_vector = torus_delta(particle_pos, _Pos[current_particle_index].xy, _WorldMin, _WorldMax);
                    const float distance = length(distance_vector);

                    if (distance < _InteractRadius)
                    {
                        const uint ti = _Type[particle_index];
                        const uint tj = _Type[current_particle_index];

                        const float attraction = pairAttr(ti, tj);
                        
                        const float force = calc_force(distance, attraction);

                        const float2 normalized_direction_vector = distance_vector / distance;
                        totalForce += normalized_direction_vector * force;
                    }
                }
                current_particle_index = _Next[current_particle_index];
            }
        }
    return totalForce;
}

[numthreads(256,1,1)]
void compute_forces(uint3 id : SV_DispatchThreadID)
{
    // guard
    uint i = id.x;
    if (i >= (uint)_ParticleCount) return;

    float2 p = _Pos[i].xy;
    float2 v = _Vel[i].xy;

    float2 F = neighbour_force(i, p);
    v += F * _DeltaTime;
    v *= _Damping;

    _Vel[i].xy = v;
    //_Vel[i].xy = float4(0.1, 0.1, 0, 0);
}

float2 wrap_2d(float2 p, float2 minW, float2 maxW)
{
    // Weltgröße (Schutz gegen 0)
    float2 size = max(maxW - minW, float2(1e-4, 1e-4));
    // In [0,1) bringen, auch für negative Werte robust (frac(x) = x - floor(x))
    float2 rel = (p - minW) / size;
    rel = frac(rel);
    return minW + rel * size;
}

[numthreads(256,1,1)]
void integrate(uint3 id : SV_DispatchThreadID)
{
    // guard
    uint i = id.x;
    if (i >= (uint)_ParticleCount) return;

    float2 p = _Pos[i].xy;
    float2 v = _Vel[i].xy;

    p += v * _DeltaTime;

    // Soft-Guard gegen Ausreißer (keine Kollisionen)
    //p = clamp(p, _WorldMin, _WorldMax);

    // --- Toroidales Wrapping ---
    p = wrap_2d(p, _WorldMin, _WorldMax);

    _Pos[i] = float4(p, 0, _Pos[i].w);
    _Vel[i] = float4(v, 0, 0);
}
